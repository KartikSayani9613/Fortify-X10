/*
 * generated by Xtext 2.13.0-SNAPSHOT
 */
package srf.transpiler.fortxtrans.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import javax.inject.Inject
import srf.transpiler.fortxtrans.fortXTrans.Component
import srf.transpiler.fortxtrans.fortXTrans.Import
import srf.transpiler.fortxtrans.fortXTrans.Export
import srf.transpiler.fortxtrans.fortXTrans.Decls
import srf.transpiler.fortxtrans.fortXTrans.Decl
import srf.transpiler.fortxtrans.fortXTrans.FnDecl
import srf.transpiler.fortxtrans.fortXTrans.ValParam
import srf.transpiler.fortxtrans.fortXTrans.FieldDecl
import srf.transpiler.fortxtrans.fortXTrans.LocalVarDecl
import srf.transpiler.fortxtrans.fortXTrans.Do
import srf.transpiler.fortxtrans.fortXTrans.DoFront
import srf.transpiler.fortxtrans.fortXTrans.BlockElems
import srf.transpiler.fortxtrans.fortXTrans.DelimitedExpr
import srf.transpiler.fortxtrans.fortXTrans.Expr
import srf.transpiler.fortxtrans.fortXTrans.Stmnts
import srf.transpiler.fortxtrans.fortXTrans.Stmnt
import srf.transpiler.fortxtrans.fortXTrans.BlockElem
import srf.transpiler.fortxtrans.fortXTrans.AddExpr
import srf.transpiler.fortxtrans.fortXTrans.LiteralTuple
import srf.transpiler.fortxtrans.fortXTrans.QualifiedName
import srf.transpiler.fortxtrans.fortXTrans.SubExpr
import srf.transpiler.fortxtrans.fortXTrans.DivExpr
import srf.transpiler.fortxtrans.fortXTrans.MultExpr
import srf.transpiler.fortxtrans.fortXTrans.FCall
import srf.transpiler.fortxtrans.fortXTrans.ExponentExpr
import srf.transpiler.fortxtrans.fortXTrans.ExprList
import srf.transpiler.fortxtrans.fortXTrans.Not
import srf.transpiler.fortxtrans.fortXTrans.Paran
import srf.transpiler.fortxtrans.fortXTrans.QualifiedNameTuple
import srf.transpiler.fortxtrans.fortXTrans.Literal
import srf.transpiler.fortxtrans.fortXTrans.Qualified
import srf.transpiler.fortxtrans.fortXTrans.LiteralTup
import srf.transpiler.fortxtrans.fortXTrans.LiteralList
import srf.transpiler.fortxtrans.fortXTrans.IntConst
import srf.transpiler.fortxtrans.fortXTrans.FloatConst
import srf.transpiler.fortxtrans.fortXTrans.StrConst
import srf.transpiler.fortxtrans.fortXTrans.BoolConst
import srf.transpiler.fortxtrans.fortXTrans.Assop
import srf.transpiler.fortxtrans.fortXTrans.TupleType
import srf.transpiler.fortxtrans.fortXTrans.Neg
import srf.transpiler.fortxtrans.fortXTrans.StmntList
import srf.transpiler.fortxtrans.fortXTrans.Elifs
import srf.transpiler.fortxtrans.fortXTrans.Else
import srf.transpiler.fortxtrans.fortXTrans.Binding
import srf.transpiler.fortxtrans.fortXTrans.GenSource
import srf.transpiler.fortxtrans.fortXTrans.Or
import srf.transpiler.fortxtrans.fortXTrans.And
import srf.transpiler.fortxtrans.fortXTrans.Equality
import srf.transpiler.fortxtrans.fortXTrans.Comparison
import srf.transpiler.fortxtrans.fortXTrans.ArrayInit
import srf.transpiler.fortxtrans.fortXTrans.ArrayCall

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FortXTransGenerator extends AbstractGenerator {
	
	def String remlast(String s){
		return s.substring(0, s.length-1)
	}

	 @Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for(c: resource.allContents.toIterable.filter(Component)){
			fsa.generateFile(
                c.fullyQualifiedName.toString("/") + ".x10",
                c.compile)
		}
	}
	
	def String compile(Component c)'''
		import x10.io.Console;
		import x10.lang.Math;
		import x10.array.Array_1;
		import x10.array.Array_2;
		import x10.array.Array_3;
		import x10.util.Random;
		/*needs to import
		«FOR i:c.imports»
			«i.compile»
		«ENDFOR»
		*/
		/*exports
		«FOR e:c.exports»
			«e.compile»
		«ENDFOR»
		*/
		
		public class «c.name»{
			
			«FOR d:c.decls»
				«d.compile»
			«ENDFOR»
			public static def nanoTime() = System.nanoTime();
			static def min(x:Double, y:Double) = Math.min(x, y);
			static def min(x:Long, y:Long) = Math.min(x, y);
			static def min(x:Int, y:Int) = Math.min(x, y);
			static def min(x:Float, y:Float) = Math.min(x, y);
			static def max(x:Long, y:Long) = Math.max(x, y);
			static def max(x:Double, y:Double) = Math.max(x, y);
			static def max(x:Int, y:Int) = Math.max(x, y);
			static def max(x:Float, y:Float) = Math.max(x, y);
			static def random(x:Double){
				var r:Random = new Random();
				return x*r.nextDouble()-1.0d;
			}
			static def sqrt(x:Double) = Math.sqrt(x);
		}
	'''
	
	def compile(Import i)'''
		«IF i.api===null»
			«i.imps» «i.importedNames.impname.compile
			»«IF i.importedNames.asname!==null
				»as «i.importedNames.asname
			»«ELSE
				»«IF i.importedNames.simpList.length !=0
				».{«
					FOR s:0..<(i.importedNames.simpList.length)
						»«IF s===0»«
							i.importedNames.simpList.get(s).orig
						»«ELSE
							», «i.importedNames.simpList.get(s).orig
						»«ENDIF
				
						»«IF i.importedNames.simpList.get(s).asName!==null
							» as «i.importedNames.simpList.get(s).asName
						»«ENDIF
					»«ENDFOR
					»«IF i.importedNames.comma
						» , ... «
					ENDIF
				»}«
				ELSE».{...}«
					IF i.importedNames.except
						» except «
						IF i.importedNames.simp.brack!==null
							»{«
							FOR s:0..<(i.importedNames.simp.nameList.length)
								»«IF s==0»«
									i.importedNames.simp.nameList.get(s).name
								»«ELSE
									», «i.importedNames.simp.nameList.get(s).name
								»«ENDIF
							»«ENDFOR
							»}«
						ELSE
							»«i.importedNames.simp.nameList.get(0).name
						»«ENDIF
					»«ENDIF
				»«ENDIF
			»«ENDIF
		»«ELSE»
			«i.imps» «i.api 
			» «IF i.aliasedimportedNames.brack!==null
				»{«
				FOR s:0..<(i.aliasedimportedNames.nameList.length)
					»«IF s==0
						»«i.aliasedimportedNames.nameList.get(0).orig
					»«ELSE
						», «i.aliasedimportedNames.nameList.get(0).orig
					»«ENDIF
					
					»«IF i.aliasedimportedNames.nameList.get(s).asName!==null
						» as «i.aliasedimportedNames.nameList.get(0).asName
					»«ENDIF
				»«ENDFOR
				»}«
			ELSE
				»«i.aliasedimportedNames.nameList.get(0).orig
				»«IF i.aliasedimportedNames.nameList.get(0).asName!==null
					» as «i.aliasedimportedNames.nameList.get(0).asName
				»«ENDIF
			»«ENDIF
		»«ENDIF»
	'''
	
	def compile(Export e)'''
		«e.exp
		» «IF e.brack!==null
			»{«
			FOR k:0..<(e.exportedName.length)
				»«IF k==0
					»«e.exportedName.get(k).compile
				»«ELSE
					», «e.exportedName.get(k).compile
				»«ENDIF
			»«ENDFOR
			»}«
		ELSE
			»«e.exportedName.get(0).compile
		»«ENDIF»
	'''
	
	def compile(QualifiedName q){
		var s = ''''''
		if(q.s.length==1)
			s = s+q.s.get(0).name
		else{
			s = s+q.s.get(0).name
			for(ss:1..<q.s.length)
				s=s+"."+q.s.get(ss).name
		}
		if(q.dots!==null)
			s=s+q.dots
		return s
	}

	def compile(ValParam p)
	'''«IF p.params.length==0
		»«
	ELSE»«
		IF p.brack===null
			»«p.params.get(0)»«
		ELSE»«
			FOR s:0..<p.params.length»«
				IF s==0»
					«p.params.get(s).parId.compile»:«
				ELSE
					», «p.params.get(s).parId.compile
				»:«ENDIF»«
				IF p.params.get(s).istype.type.name=="ZZ32"
					»Int«
				ELSE»«
					IF p.params.get(s).istype.type.name=="ZZ64"
						»Long«
					ELSE»«
						IF p.params.get(s).istype.type.name=="RR32"
							»Float«
						ELSE»«
							IF p.params.get(s).istype.type.name=="RR64"
								»Double«
							ELSE»«
								IF p.params.get(s).istype.type.name=="String"
									»String«
								ELSE»«
									p.params.get(s).istype.type.name									
								»«ENDIF
							»«ENDIF
						»«ENDIF
					»«ENDIF
				»«ENDIF
			»«ENDFOR
		»«ENDIF
	»«ENDIF»'''
	
	def compile(Decls d)'''
		«FOR dec:d.decls»
			«dec.compile»
		«ENDFOR»
	'''
	
	def compile(Decl d)'''
		«IF d.function!==null»
			«d.function.compile»
		«ELSE» «IF d.field!==null»
			«d.field.compile»
			«ENDIF»
		«ENDIF»
	'''
	
	def compile(FieldDecl f){
		var s = ""
		if(f.vars!==null)
		{
			if(f.vars.single!==null){
				if(f.pri!==null)
					s = s + '''private '''
				if(f.mut===null)
					s = s + '''static val '''
				else
					s = s + '''var '''
				s = s + f.vars.single.bid.compile+":"
				if(f.vars.arrsize!==null){
					var arrt = f.vars.arrsize.compile.split("@")
					s = s + '''Array_«arrt.length»['''
					var type = f.vars.single.istype.type.name
					if(type=="ZZ32")
						s=s+'''Int] = '''+f.init.compile+";"
					else if(type=="ZZ64")
						s=s+'''Long] = '''+f.init.compile+";"
					else if(type=="RR32")
						s=s+'''Float] = '''+f.init.compile+";"
					else if(type=="RR64")
						s=s+'''Double] = '''+f.init.compile+";"
					else if(type=="String")
						s=s+'''String] = '''+f.init.compile+";"
					else
						s = s+ type + '''] = ''' + f.init.compile+";";
				}
				else{
					var type = f.vars.single.istype.type.name
					if(type=="ZZ32")
						s=s+'''Int = '''+f.init.compile+" as Int;"
					else if(type=="ZZ64")
						s=s+'''Long = '''+f.init.compile+" as Long;"
					else if(type=="RR32")
						s=s+'''Float = '''+f.init.compile+" as Float;"
					else if(type=="RR64")
						s=s+'''Double = '''+f.init.compile+" as Double;"
					else if(type=="String")
						s=s+'''String = '''+f.init.compile+";"
					else
						s = s+ type + "= " + f.init.compile+";";		
				}
			}
			else{
				var attach = f.init.compile.split("@")
				for(m:0..<f.vars.multiple.length){
					if(f.pri!==null)
						s = s + '''private '''
					if(f.mut===null)
						s = s + '''static val '''
					else
						s = s + '''var '''
					s = s + f.vars.multiple.get(m).bid.compile+":"
					var type = f.vars.multiple.get(m).istype.type.name
					if(type=="ZZ32")
						s=s+'''Int = '''+ attach.get(m)+" as Int;"
					else if(type=="ZZ64")
						s=s+'''Long = ''' + attach.get(m)+" as Long;"
					else if(type=="RR32")
							s=s+'''Float = ''' + attach.get(m)+" as Float;"
					else if(type=="RR64")
						s=s+'''Double = ''' + attach.get(m)+" as Double;"
					else if(type=="String")
						s=s+'''String = '''+ attach.get(m)+";"
					else{
						s = s+ type + "= " + attach.get(m)+";";	
					}
					s = s+"\n"
				}
			}
		}
		else if(f.type!==null){
			var vars = f.idtup.compile.split(",")
			var vals = f.init.compile.split("@")
			for(v:0..<vars.length){
				if(f.pri!==null)
					s = s+'''private '''
				if(f.mut===null)
					s = s+'''static val '''
				else
					s = s+'''var '''
				s = s + vars.get(v)+":"
				var type = f.type.name
				if(type=="ZZ32")
					s=s+'''Int = '''+ vals.get(v) +" as Int;"
				else if(type=="ZZ64")
					s=s+'''Long = ''' + vals.get(v) +" as Long;"
				else if(type=="RR32")
					s=s+'''Float = ''' + vals.get(v) +" as Float;"
				else if(type=="RR64")
					s=s+'''Double = ''' + vals.get(v) +" as Double;"
				else if(type=="String")
					s=s+'''String = '''+ vals.get(v) +";"
				else
					s = s+ type + "= " + vals.get(v) +";";	
				s = s+"\n"
			}
			
		}
		else if(f.tuptype!==null){
			var vars = f.idtup.compile.split(",")
			var types = f.tuptype.compile.split(",")
			var vals = f.init.compile.split("@")
			for(k:0..<vars.length){
				if(f.pri!==null)
					s = s+'''private '''
				if(f.mut===null)
					s = s+'''static val '''
				else
					s = s+'''var '''
				s = s + vars.get(k) + ":"
				var type = types.get(k)
				if(type=="ZZ32")
					s=s+'''Int = '''+ vals.get(k) +" as Int;"
				else if(type=="ZZ64")
					s=s+'''Long = ''' + vals.get(k) +" as Long;"
				else if(type=="RR32")
					s=s+'''Float = ''' + vals.get(k) +" as Float;"
				else if(type=="RR64")
					s=s+'''Double = ''' + vals.get(k) +" as Double;"
				else if(type=="String")
					s=s+'''String = '''+ vals.get(k) +";"
				else
					s = s+ type + "= " + vals.get(k) +";";	
				s = s+"\n"
			}
		}
		else{
			var vars = f.idtup.compile.split(",")
			var vals = f.init.compile.split("@")
			for(k:0..<vars.length){
				if(f.pri!==null)
					s = s+'''private '''
				s = s + '''static val '''
				s = s + vars.get(k) + ''' = ''' + vals.get(k)
			}
		}
		return s
	}
	
	def String compile(TupleType tp){
		var s = ""
		s = s + tp.types.get(0).name
		for(k:1..<tp.types.length)
			s = s+","+tp.types.get(k).name
		return s
	}
	
	def String compile(LiteralTuple lt){
		switch(lt){
			Qualified: return lt.compile
			LiteralTup: return lt.compile
		}
	}
	
	def String compile(Qualified q){
		switch(q){
			QualifiedName: return q.compile
			QualifiedNameTuple: return q.compile
		}
	}
	
	def String compile(QualifiedNameTuple qt){
		var s = ""
		s = s + qt.qlist.get(0).compile
		for(q:1..<qt.qlist.length)
			s = s + "," + qt.qlist.get(q).compile
		return s
	}
	
	def String compile(LiteralTup lt){
		switch(lt){
			Literal: return lt.compile
			LiteralList: return lt.compile
		}
	}
	
	def String compile(Literal l){
		switch(l){
			IntConst: return l.value.toString+"n"
			FloatConst: return l.value.toString+"f"
			StrConst: return "\""+l.value+"\""
			BoolConst: return l.value
		}
	}
	
	def String compile(LiteralList ll){
		var s = ""
		s = s + ll.lit.get(0).compile
		for(l:1..<ll.lit.length)
			s = s + "," + ll.lit.get(l).compile
		return s
	}
	
	def compile(FnDecl f){
		var s = ""
		if(f.name=="run")
			s = s + '''public static def main(args:Rail[String])'''
		else{
			if(f.mods!==null)
				for(m:f.mods.mods)
					s = s + m.modtype +" ";
			s = s + '''static def ''' + f.name + '''('''
			if(f.params!==null)
				s = s + f.params.compile
			 s = s + ''')'''
			 if(f.retVal!==null)
			 	if(f.retVal.empty=='(')
			 		s = s + ''':void'''
			 	else if (f.retVal.type.name=="ZZ32")
			 		s = s + ''':Int'''
			 	else if (f.retVal.type.name=="ZZ64")
			 		s = s + ''':Long'''
			 	else if (f.retVal.type.name=="RR32")
			 		s = s + ''':Float'''
			 	else if (f.retVal.type.name=="RR64")
			 		s = s + ''':Double'''
			 	else
			 		s =s + f.retVal.type.name
		}
		if(f.body)
			s = s + '''{'''+ "\n\t" + f.fnItself.compile + "\n"+'''}'''
	}
	
	def String compile(Stmnts st){
	
	if(st.front!==null)
		return st.front.compile
	else if(st.delims!==null)
		return st.delims.compile
	else if (st.locVar!==null)
		return st.locVar.compile
	else
		switch(st.exp){
			Assop: return st.exp.compile
			default: return st.exp.compile+";"
		}
	}
	
	def compile(Stmnt s){
		if(s.delim!==null)
			return s.delim.compile
	}
	
	def String compile(StmntList d){
		var s = "finish{"
		for(dd:d.delim)
			s=s+'''async{
					«dd.compile»
				}'''		
		s = s+"}"
		return s
	}
	
	def String compile(DelimitedExpr d){
	
		if(d.dod!==null)
			return d.dod.compile+"\n"
		else if(d.ret!==null)
			return "return " + d.block.compile+";\n"
		else if(d.awhile!==null)
			return '''while('''+d.expr.compile+''')'''+'''{'''+"\n"+d.whiledod.compile + "\n"+'''}'''+"\n"
		else if(d.afor!==null){
			var s = ""
			if(d.gen.binding.seq===null)
				s = s + '''finish '''
			s = s+'''for('''+d.gen.binding.compile+''' in '''+d.gen.binding.g.compile+''')'''
			if(d.gen.binding.seq===null)
				s = s + ''' async{'''+"\n\t"
			else
				s = s +'''{'''+"\n\t"
			if(d.gen.clause!==null){
				for(c:d.gen.clause){
					s = s + '''{'''+"\n"
					if(c.binding.seq===null)
						s = s + "\t"+'''finish '''
					s = s + '''for('''+c.binding.compile+'''in'''+c.binding.g.compile+''')'''
					if(c.binding.seq===null)
						s = s + ''' async{'''+"\n\t"
					else
						s = s +'''{'''+"\n\t"
				}
				s = s + d.dofront.compile
				for(c:d.gen.clause)
					s = s + "\n\t"+'''}'''
			}
			else
				s = s + d.dofront.compile
			s = s + "\n\t"+'''}'''+"\n"
			return s
		}
		else if(d.anif!==null){
			var s= '''if('''+d.cond.compile+''')'''+'''{'''+"\n"+d.blocks.compile + "\n"+'''}'''+"\n"
			if(d.elifs!==null)
				s = s + d.elifs.compile
			if(d.els!==null)
				s = s + d.els.compile 
			return s
		}
			
	}
	
	def compile(GenSource g){
		switch(g){
			Expr: return g.compile
			GenSource: return g.start.compile+'''..'''+'''('''+g.end.compile+'''-1)'''
		}
	}
	
	def compile(Binding b){
		switch(b.idtup){
			QualifiedName: return b.idtup.compile
			QualifiedNameTuple: return "["+b.idtup.compile+"]"
		}
	}
	
	def compile(Elifs el){
		var s = ""
		for(e:el.e)
			s = s + '''else if('''+e.expr.compile+''')'''+'''{'''+"\n"+e.block.compile + "\n"+'''}'''
		return s
	}
	
	def compile(Else e){
		var s = '''else{'''+"\n"
		s = s +e.block.compile + '''}'''+"\n"
	}
	
	def compile(Do dobox){
		var s = ""
		if(dobox.dofs.length==1)
			s = s + dobox.dofs.get(0).compile
		else{
			s = s + '''finish{
				'''
			for(d:dobox.dofs)
				s = s + '''
				async{
					«d.compile»
				}
				'''
			s = s + '''
			}'''	
		}
		return s
	}
	
	def compile(DoFront dof){
		var s = ""
		if(dof.at)
			s = s + '''at(«dof.exp.compile») '''
		if(dof.atom)
			s = s + '''
			atomic{
				«dof.block.compile»
			}'''
		else
			s = s + dof.block.compile
		return s
	}
	
	def compile(BlockElems bs)'''
	«FOR b:bs.block»
	«b.compile»
	«ENDFOR»
	'''
	
	def compile (BlockElem b)'''
	«b.st.compile»
	'''
	
	def String compile(LocalVarDecl f){
		var s = ""
		if(f.vars!==null)
		{
			if(f.vars.single!==null){
				if(f.mut===null)
					s = s + '''val '''
				else
					s = s + '''var '''
				s = s + f.vars.single.bid.compile+":"
				if(f.vars.arrsize!==null){
					var arrt = f.vars.arrsize.compile.split("@")
					s = s + '''Array_«arrt.length»['''
					var type = f.vars.single.istype.type.name
					if(type=="ZZ32")
						s=s+'''Int] = '''+f.init.compile+";"
					else if(type=="ZZ64")
						s=s+'''Long] = '''+f.init.compile+";"
					else if(type=="RR32")
						s=s+'''Float] = '''+f.init.compile+";"
					else if(type=="RR64")
						s=s+'''Double] = '''+f.init.compile+";"
					else if(type=="String")
						s=s+'''String] = '''+f.init.compile+";"
					else
						s = s+ type + '''] = ''' + f.init.compile+";";
				}
				else{
					var type = f.vars.single.istype.type.name
					if(type=="ZZ32")
						s=s+'''Int = '''+f.init.compile+" as Int;"
					else if(type=="ZZ64")
						s=s+'''Long = '''+f.init.compile+" as Long;"
					else if(type=="RR32")
						s=s+'''Float = '''+f.init.compile+" as Float;"
					else if(type=="RR64")
						s=s+'''Double = '''+f.init.compile+" as Double;"
					else if(type=="String")
						s=s+'''String = '''+f.init.compile+";"
					else
						s = s+ type + "= " + f.init.compile+";";		
				}
				
			}
			else{
				var attach = f.init.compile.split("@")
				for(m:0..<f.vars.multiple.length){
					if(f.mut===null)
						s = s + '''val '''
					else
						s = s + '''var '''
					s = s + f.vars.multiple.get(m).bid.compile+":"
					var type = f.vars.multiple.get(m).istype.type.name
					if(type=="ZZ32")
						s=s+'''Int = '''+ attach.get(m)+" as Int;"
					else if(type=="ZZ64")
						s=s+'''Long = ''' + attach.get(m)+" as Long;"
					else if(type=="RR32")
							s=s+'''Float = ''' + attach.get(m)+" as Float;"
					else if(type=="RR64")
						s=s+'''Double = ''' + attach.get(m)+" as Double;"
					else if(type=="String")
						s=s+'''String = '''+ attach.get(m)+";"
					else{
						s = s+ type + "= " + attach.get(m)+";";	
					}
					s = s+"\n"
				}
			}
		}
		else if(f.type!==null){
			var vars = f.idtup.compile.split(",")
			var vals = f.init.compile.split("@")
			for(v:0..<vars.length){
				if(f.mut===null)
					s = s+'''val '''
				else
					s = s+'''var '''
				s = s + vars.get(v)+":"
				var type = f.type.name
				if(type=="ZZ32")
					s=s+'''Int = '''+ vals.get(v) +" as Int;"
				else if(type=="ZZ64")
					s=s+'''Long = ''' + vals.get(v) +" as Long;"
				else if(type=="RR32")
					s=s+'''Float = ''' + vals.get(v) +" as Float;"
				else if(type=="RR64")
					s=s+'''Double = ''' + vals.get(v) +" as Double;"
				else if(type=="String")
					s=s+'''String = '''+ vals.get(v) +";"
				else
					s = s+ type + "= " + vals.get(v) +";";	
				s = s+"\n"
			}
			
		}
		else if(f.tuptype!==null){
			var vars = f.idtup.compile.split(",")
			var types = f.tuptype.compile.split(",")
			var vals = f.init.compile.split("@")
			for(k:0..<vars.length){
				if(f.mut===null)
					s = s+'''val '''
				else
					s = s+'''var '''
				s = s + vars.get(k) + ":"
				var type = types.get(k)
				if(type=="ZZ32")
					s=s+'''Int = '''+ vals.get(k) +" as Int;"
				else if(type=="ZZ64")
					s=s+'''Long = ''' + vals.get(k) +" as Long;"
				else if(type=="RR32")
					s=s+'''Float = ''' + vals.get(k) +" as Float;"
				else if(type=="RR64")
					s=s+'''Double = ''' + vals.get(k) +" as Double;"
				else if(type=="String")
					s=s+'''String = '''+ vals.get(k) +";"
				else
					s = s+ type + "= " + vals.get(k) +";";	
				s = s+"\n"
			}
		}
		else{
			var vars = f.idtup.compile.split(",")
			var vals = f.init.compile.split("@")
			for(k:0..<vars.length){
				s = s + '''val '''
				s = s + vars.get(k) + ''' = ''' + vals.get(k)+";\n"
			}
		}
		return s
	}
	
	def String typer(String s){
		if(s=="ZZ32")
			return "Int"
		else if(s=="ZZ64")
			return "Long"
		else if(s=="RR32")
			return "Float"
		else if(s=="RR64")
			return "Double"
		else
			return s
	}
	
	def String compile(Expr e){
		var s = ""
		switch(e){
			Or: s = s + '''(«e.left.compile»||«e.right.compile»)'''
			And: s = s + '''(«e.left.compile»&&«e.right.compile»)'''
			Equality:	{
							s = s + '''(«e.left.compile»'''
							if(e.op=="===" || e.op=="EQ")
								s = s + ''' == '''
							else
								s = s + ''' != '''
							s = s + '''«e.right.compile»)'''
						}
			Comparison:	{
							s = s + '''(«e.left.compile»'''
							if(e.op==">=" || e.op=="GE")
								s = s + ''' >= '''
							else if(e.op=="<="||e.op=="LT")
								s = s + ''' <= '''
							else if(e.op=="<"||e.op=="LT")
								s = s + ''' < '''
							else if(e.op==">"||e.op=="GT")
								s = s + ''' > '''
							s = s + '''«e.right.compile»)'''
						}
			AddExpr: s = s+'''(«e.left.compile»+«e.right.compile»)'''
			SubExpr: s = s+'''(«e.left.compile»-«e.right.compile»)'''
			DivExpr: s = s+'''(«e.left.compile»/«e.right.compile»)'''
			MultExpr: s = s+'''(«e.left.compile»*«e.right.compile»)'''
			ExponentExpr: s = s+'''(Math.pow(«e.left.compile»,«e.right.compile»))'''
			Not:s=s+"!"+'''('''+e.expression.compile+''')'''
			Neg:s=s+"-"+'''('''+e.expression.compile+''')'''
			Paran:s=s+'''«e.exp.compile»'''
			ArrayInit: {
				var ltp = e.left.compile
				var t = typer(e.type.name)
				if(ltp=="array1"|| ltp=="vector")
					s = s + '''new Array_1['''
				else if(ltp=="array2"||ltp=="matrix")
					s = s + '''new Array_2['''
				else if(ltp=="array3")
					s = s + '''new Array_3['''
				s = s + '''«t»](«e.sizes.compile.replace("@",",")»'''
				if(e.lit!==null)
					s = s + ''', «e.lit.compile»'''
				else if(e.filler!==null){
					var vars = e.ind.compile.split(",")
					s = s + ''', («vars.get(0)»:Long'''
					for(k:1..<vars.length)
						s = s + ''', «vars.get(k)»:Long'''
					s = s + '''):«t»'''
					s = s + ''' => {''' + e.filler.compile +'''}'''
				}
				s = s + ''')'''
			}
			FCall:	{	var fname = e.left.compile
						if(fname=="println"||fname=="print")
							s = s + '''Console.OUT.«e.left.compile»(«IF e.right!==null»«e.right.compile.replace("@","+")»«ENDIF»)'''
						else
							s=s+'''«fname»(«IF e.right!==null»«e.right.compile.replace("@",",")»«ENDIF»)'''
							
					}
			ArrayCall:s = s + '''«e.left.compile»(«e.right.compile.replace("@",",")»)«IF e.extRight!==null»=«e.extRight.compile»«ENDIF»'''
			LiteralTuple: s= s+e.compile
			Assop: s = e.compile
		}
		if(e.tail!==null)
			for(t:e.tail){
				s = s + ''' as '''
				var tp = t.type.name
				if(tp=="ZZ32")
					s = s + '''Int'''
				else if(tp=="ZZ64")
					s = s + '''Long'''
				else if(tp=="RR32")
					s = s + '''Float'''
				else if(tp=="RR64")
					s = s + '''Double'''
				else
					s = s + tp
			}
		return s
	}
	
	def String compile(Assop a){
		var s = ""
		var lefts = a.left.compile.split(",")
		var rights = a.right.compile.split('@')
		if(lefts.length==1)
			s = s + lefts.get(0)+ ''' = ''' + rights.get(0) + ";\n"
		else{
			s = s + '''finish {
				'''
			for(k:0..<lefts.length)
				s = s + '''async{ ''' + lefts.get(k)+ ''' = ''' + rights.get(k) + '''}''' + ";\n"
			s = s + '''}'''+"\n"
		}
		
		return s
	}
	
	def compile(ExprList e){
		var s = ""
		s = s + e.exps.compile
		for(ex:e.exp)
			s = s + "@" + ex.compile	
		return s
	}
   
}