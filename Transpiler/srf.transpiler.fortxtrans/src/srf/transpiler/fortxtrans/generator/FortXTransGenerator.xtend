/*
 * generated by Xtext 2.13.0-SNAPSHOT
 */
package srf.transpiler.fortxtrans.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import javax.inject.Inject
import srf.transpiler.fortxtrans.fortXTrans.Component
import srf.transpiler.fortxtrans.fortXTrans.Import
import srf.transpiler.fortxtrans.fortXTrans.Export
import srf.transpiler.fortxtrans.fortXTrans.Decls
import srf.transpiler.fortxtrans.fortXTrans.Decl
import srf.transpiler.fortxtrans.fortXTrans.FnDecl
import srf.transpiler.fortxtrans.fortXTrans.ValParam
import srf.transpiler.fortxtrans.fortXTrans.FieldDecl
import srf.transpiler.fortxtrans.fortXTrans.LocalVarDecl
import srf.transpiler.fortxtrans.fortXTrans.Elifs
import srf.transpiler.fortxtrans.fortXTrans.Binding
import srf.transpiler.fortxtrans.fortXTrans.Do
import srf.transpiler.fortxtrans.fortXTrans.DoFront
import srf.transpiler.fortxtrans.fortXTrans.BlockElems
import srf.transpiler.fortxtrans.fortXTrans.DelimitedExpr
import srf.transpiler.fortxtrans.fortXTrans.ExprTail
import srf.transpiler.fortxtrans.fortXTrans.Expr
import srf.transpiler.fortxtrans.fortXTrans.Stmnts
import srf.transpiler.fortxtrans.fortXTrans.Stmnt
import srf.transpiler.fortxtrans.fortXTrans.BlockElem
import srf.transpiler.fortxtrans.fortXTrans.Qualified
import srf.transpiler.fortxtrans.fortXTrans.AddExpr
import srf.transpiler.fortxtrans.fortXTrans.LiteralTuple
import srf.transpiler.fortxtrans.fortXTrans.QualifiedName

import srf.transpiler.fortxtrans.fortXTrans.BlockElems
import srf.transpiler.fortxtrans.fortXTrans.LocalVarDecl
import srf.transpiler.fortxtrans.fortXTrans.SubExpr
import srf.transpiler.fortxtrans.fortXTrans.DivExpr
import srf.transpiler.fortxtrans.fortXTrans.MultExpr
import srf.transpiler.fortxtrans.fortXTrans.FCall
import srf.transpiler.fortxtrans.fortXTrans.Literal
import srf.transpiler.fortxtrans.fortXTrans.IntConst
import srf.transpiler.fortxtrans.fortXTrans.FloatConst
import srf.transpiler.fortxtrans.fortXTrans.StrConst
import srf.transpiler.fortxtrans.fortXTrans.LiteralList
import srf.transpiler.fortxtrans.fortXTrans.QualifiedNameTuple
import srf.transpiler.fortxtrans.fortXTrans.ExponentExpr
import srf.transpiler.fortxtrans.fortXTrans.SimpleName
import srf.transpiler.fortxtrans.fortXTrans.Assop
import srf.transpiler.fortxtrans.fortXTrans.ExprList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FortXTransGenerator extends AbstractGenerator {

	 @Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for(c: resource.allContents.toIterable.filter(Component)){
			fsa.generateFile(
                c.fullyQualifiedName.toString("/") + ".x10",
                c.compile)
		}
	}
	
	def String compile(Component c)'''
		import x10.io.Console;
		import x10.lang.Math;
		import x10.array.Array_1;
		import x10.array.Array_2;
		import x10.array.Array_3;
		/*needs to import
		«FOR i:c.imports»
			«i.compile»
		«ENDFOR»
		*/
		/*exports
		«FOR e:c.exports»
			«e.compile»
		«ENDFOR»
		*/
		
		public class «c.name»{
			«FOR d:c.decls»
				«d.compile»
			«ENDFOR»
		}
	'''
	
	def compile(Import i)'''
		«IF i.api===null»
			«i.imps» «i.importedNames.impname
			»«IF i.importedNames.asname!==null
				»as «i.importedNames.asname
			»«ELSE
				»«IF i.importedNames.simpList.length !=0
				».{«
					FOR s:0..<(i.importedNames.simpList.length)
						»«IF s===0»«
							i.importedNames.simpList.get(s).orig
						»«ELSE
							», «i.importedNames.simpList.get(s).orig
						»«ENDIF
				
						»«IF i.importedNames.simpList.get(s).asName!==null
							» as «i.importedNames.simpList.get(s).asName
						»«ENDIF
					»«ENDFOR
					»«IF i.importedNames.comma
						» , ... «
					ENDIF
				»}«
				ELSE».{...}«
					IF i.importedNames.except
						» except «
						IF i.importedNames.simp.brack!==null
							»{«
							FOR s:0..<(i.importedNames.simp.nameList.length)
								»«IF s==0»«
									i.importedNames.simp.nameList.get(s).name
								»«ELSE
									», «i.importedNames.simp.nameList.get(s).name
								»«ENDIF
							»«ENDFOR
							»}«
						ELSE
							»«i.importedNames.simp.nameList.get(0).name
						»«ENDIF
					»«ENDIF
				»«ENDIF
			»«ENDIF
		»«ELSE»
			«i.imps» «i.api 
			» «IF i.aliasedimportedNames.brack!==null
				»{«
				FOR s:0..<(i.aliasedimportedNames.nameList.length)
					»«IF s==0
						»«i.aliasedimportedNames.nameList.get(0).orig
					»«ELSE
						», «i.aliasedimportedNames.nameList.get(0).orig
					»«ENDIF
					
					»«IF i.aliasedimportedNames.nameList.get(s).asName!==null
						» as «i.aliasedimportedNames.nameList.get(0).asName
					»«ENDIF
				»«ENDFOR
				»}«
			ELSE
				»«i.aliasedimportedNames.nameList.get(0).orig
				»«IF i.aliasedimportedNames.nameList.get(0).asName!==null
					» as «i.aliasedimportedNames.nameList.get(0).asName
				»«ENDIF
			»«ENDIF
		»«ENDIF»
	'''
	
	def compile(Export e)'''
		«e.exp
		» «IF e.brack!==null
			»{«
			FOR k:0..<(e.exportedName.length)
				»«IF k==0
					»«e.exportedName.get(k).compile
				»«ELSE
					», «e.exportedName.get(k).compile
				»«ENDIF
			»«ENDFOR
			»}«
		ELSE
			»«e.exportedName.get(0)
		»«ENDIF»
	'''
	
	def compile(QualifiedName q){
		var s = ''''''
		if(q.s.length==1)
			s = s+q.s.get(0).name
		else{
			s = s+q.s.get(0).name
			for(ss:1..<q.s.length)
				s=s+"."+q.s.get(ss).name
		}
			
		if(q.dots!==null)
			s=s+q.dots
		return s
	}
	
	def compile(ValParam p)
	'''«IF p.params.length==0
		»«
	ELSE»«
		IF p.brack===null
			»«p.params.get(0)»«
		ELSE»«
			FOR s:0..<p.params.length»«
				IF s==0
					»«p.params.get(s).BId»:«
				ELSE
					», «p.params.get(s).BId
				»:«ENDIF»«
				IF p.params.get(s).istype.type.name=="ZZ32"
					»Int«
				ELSE»«
					IF p.params.get(s).istype.type.name=="ZZ64"
						»Long«
					ELSE»«
						IF p.params.get(s).istype.type.name=="RR32"
							»Float«
						ELSE»«
							IF p.params.get(s).istype.type.name=="RR64"
								»Double«
							ELSE»«
								IF p.params.get(s).istype.type.name=="String"
									»String«
								ELSE»«
									p.params.get(s).istype.type.name									
								»«ENDIF
							»«ENDIF
						»«ENDIF
					»«ENDIF
				»«ENDIF
			»«ENDFOR
		»«ENDIF
	»«ENDIF»'''
	
	def compile(Decls d)'''
		«FOR dec:d.decls»
			«dec.compile»
		«ENDFOR»
	'''
	
	def compile(Decl d)'''
		«IF d.function!==null»
			«d.function.compile»
		«ELSE» «IF d.field!==null»
			«d.field.compile»
			«ENDIF»
		«ENDIF»
	'''
	
	def compile(FieldDecl f)
	'''
	//FieldDecl'''
	
	def compile(FnDecl f)'''
	//FnDecl
	«IF f.body»
	«f.fnItself.compile»
	«ENDIF»'''
	
	def String compile(Stmnts st)'''
	//Statements
	«IF st.front!==null»«st.front.compile»«
	ELSE»«IF st.locVar!==null»«st.locVar.compile»«
	ELSE»
	«IF st.exp!==null»«st.exp.compile
	»«ENDIF»
	«ENDIF»«ENDIF»
	'''
	
	def compile(Stmnt s)'''
	//Statement«s.delim.compile»
	'''
	
	def compile(DelimitedExpr d)'''
	//DelimExpr«d.dod.compile»
	'''
	
	def compile(Do d)'''
	//Do«d.dofs.get(0).compile»
	'''
	
	def compile(DoFront df)'''
	//DoFront«df.block.compile»
	'''
	
	def compile(BlockElems bs)'''
	//BlockElems
	«FOR b:bs.block»
	«b.compile»
	«ENDFOR»
	'''
	
	def compile (BlockElem b)'''
	//BlockElem«b.st.compile»
	'''
	
	def compile(LocalVarDecl d)'''
	//LocalVar «d.init.compile»
	'''
	
	def String compile(Expr e){
		var s = ""
		switch(e){
			AddExpr: s = s+'''(«e.left.compile»+«e.right.compile»)'''
			SubExpr: s = s+'''(«e.left.compile»-«e.right.compile»)'''
			DivExpr: s = s+'''(«e.left.compile»/«e.right.compile»)'''
			MultExpr: s = s+'''(«e.left.compile»*«e.right.compile»)'''
			ExponentExpr: s = s+'''(Math.pow(«e.left.compile»,«e.right.compile»))'''
			FCall:s=s+'''yolo(«e.right.exps.compile»)'''
			
		}
		return s
	}
	
	def compile(ExprList e){
		var s = ""
					
		return s
	}
   
}