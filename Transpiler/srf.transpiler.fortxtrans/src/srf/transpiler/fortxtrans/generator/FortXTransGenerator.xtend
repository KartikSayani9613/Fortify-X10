/*
 * generated by Xtext 2.13.0-SNAPSHOT
 */
package srf.transpiler.fortxtrans.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import javax.inject.Inject
import srf.transpiler.fortxtrans.fortXTrans.Component
import srf.transpiler.fortxtrans.fortXTrans.Import
import srf.transpiler.fortxtrans.fortXTrans.Export
import srf.transpiler.fortxtrans.fortXTrans.Decls
import srf.transpiler.fortxtrans.fortXTrans.Decl
import srf.transpiler.fortxtrans.fortXTrans.FnDecl
import srf.transpiler.fortxtrans.fortXTrans.ValParam
import srf.transpiler.fortxtrans.fortXTrans.FieldDecl
import srf.transpiler.fortxtrans.fortXTrans.LocalVarDecl
import srf.transpiler.fortxtrans.fortXTrans.Elifs
import srf.transpiler.fortxtrans.fortXTrans.Binding
import srf.transpiler.fortxtrans.fortXTrans.Do
import srf.transpiler.fortxtrans.fortXTrans.DoFront
import srf.transpiler.fortxtrans.fortXTrans.BlockElems
import srf.transpiler.fortxtrans.fortXTrans.DelimitedExpr
import srf.transpiler.fortxtrans.fortXTrans.ExprFront
import srf.transpiler.fortxtrans.fortXTrans.ExprTail
import srf.transpiler.fortxtrans.fortXTrans.Expr
import srf.transpiler.fortxtrans.fortXTrans.Stmnts
import srf.transpiler.fortxtrans.fortXTrans.Stmnt
import srf.transpiler.fortxtrans.fortXTrans.BlockElem
import srf.transpiler.fortxtrans.fortXTrans.CommaExpr
import srf.transpiler.fortxtrans.fortXTrans.impl.CommaExprImpl
import org.eclipse.emf.ecore.EObject
import srf.transpiler.fortxtrans.fortXTrans.Qualified
import srf.transpiler.fortxtrans.fortXTrans.AddExpr
import srf.transpiler.fortxtrans.fortXTrans.Primary
import srf.transpiler.fortxtrans.fortXTrans.LiteralTuple

//import srf.transpiler.fortxtrans.fortXTrans.Expr
//import srf.transpiler.fortxtrans.fortXTrans.ExprFront
//import srf.transpiler.fortxtrans.fortXTrans.ExprTail
//import srf.transpiler.fortxtrans.fortXTrans.DelimitedExpr
//import srf.transpiler.fortxtrans.fortXTrans.Do
//import srf.transpiler.fortxtrans.fortXTrans.DoFront
//import srf.transpiler.fortxtrans.fortXTrans.BlockElems
//import srf.transpiler.fortxtrans.fortXTrans.Binding
//import srf.transpiler.fortxtrans.fortXTrans.Elifs
//import srf.transpiler.fortxtrans.fortXTrans.LocalVarDecl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FortXTransGenerator extends AbstractGenerator {

	 @Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for(c: resource.allContents.toIterable.filter(Component)){
			fsa.generateFile(
                c.fullyQualifiedName.toString("/") + ".x10",
                c.compile)
		}
	}
	
	def String compile(Component c)'''
		import x10.io.Console;
		import x10.lang.Math;
		import x10.array.Array_1;
		import x10.array.Array_2;
		import x10.array.Array_3;
		/*needs to import
		«FOR i:c.imports»
			«i.compile»
		«ENDFOR»
		*/
		/*exports
		«FOR e:c.exports»
			«e.compile»
		«ENDFOR»
		*/
		
		public class «c.name»{
			«FOR d:c.decls»
				«d.compile»
			«ENDFOR»
		}
	'''
	
	def compile(Import i)'''
		«IF i.api===null»
			«i.imps» «i.importedNames.impname
			»«IF i.importedNames.asname!==null
				»as «i.importedNames.asname
			»«ELSE
				»«IF i.importedNames.simpList.length !=0
				».{«
					FOR s:0..<(i.importedNames.simpList.length)
						»«IF s===0»«
							i.importedNames.simpList.get(s).orig
						»«ELSE
							», «i.importedNames.simpList.get(s).orig
						»«ENDIF
				
						»«IF i.importedNames.simpList.get(s).asName!==null
							» as «i.importedNames.simpList.get(s).asName
						»«ENDIF
					»«ENDFOR
					»«IF i.importedNames.comma
						» , ... «
					ENDIF
				»}«
				ELSE».{...}«
					IF i.importedNames.except
						» except «
						IF i.importedNames.simp.brack!==null
							»{«
							FOR s:0..<(i.importedNames.simp.nameList.length)
								»«IF s==0»«
									i.importedNames.simp.nameList.get(s).name
								»«ELSE
									», «i.importedNames.simp.nameList.get(s).name
								»«ENDIF
							»«ENDFOR
							»}«
						ELSE
							»«i.importedNames.simp.nameList.get(0).name
						»«ENDIF
					»«ENDIF
				»«ENDIF
			»«ENDIF
		»«ELSE»
			«i.imps» «i.api 
			» «IF i.aliasedimportedNames.brack!==null
				»{«
				FOR s:0..<(i.aliasedimportedNames.nameList.length)
					»«IF s==0
						»«i.aliasedimportedNames.nameList.get(0).orig
					»«ELSE
						», «i.aliasedimportedNames.nameList.get(0).orig
					»«ENDIF
					
					»«IF i.aliasedimportedNames.nameList.get(s).asName!==null
						» as «i.aliasedimportedNames.nameList.get(0).asName
					»«ENDIF
				»«ENDFOR
				»}«
			ELSE
				»«i.aliasedimportedNames.nameList.get(0).orig
				»«IF i.aliasedimportedNames.nameList.get(0).asName!==null
					» as «i.aliasedimportedNames.nameList.get(0).asName
				»«ENDIF
			»«ENDIF
		»«ENDIF»
	'''
	
	def compile(Export e)'''
		«e.exp
		» «IF e.brack!==null
			»{«
			FOR s:0..<(e.exportedName.length)
				»«IF s==0
					»«e.exportedName.get(s)
				»«ELSE
					», «e.exportedName.get(s)
				»«ENDIF
			»«ENDFOR
			»}«
		ELSE
			»«e.exportedName.get(0)
		»«ENDIF»
	'''
	
	def compile(ValParam p)
	'''«IF p.params.length==0
		»«
	ELSE»«
		IF p.brack===null
			»«p.params.get(0)»«
		ELSE»«
			FOR s:0..<p.params.length»«
				IF s==0
					»«p.params.get(s).BId»:«
				ELSE
					», «p.params.get(s).BId
				»:«ENDIF»«
				IF p.params.get(s).istype.type.name=="ZZ32"
					»Int«
				ELSE»«
					IF p.params.get(s).istype.type.name=="ZZ64"
						»Long«
					ELSE»«
						IF p.params.get(s).istype.type.name=="RR32"
							»Float«
						ELSE»«
							IF p.params.get(s).istype.type.name=="RR64"
								»Double«
							ELSE»«
								IF p.params.get(s).istype.type.name=="String"
									»String«
								ELSE»«
									p.params.get(s).istype.type.name									
								»«ENDIF
							»«ENDIF
						»«ENDIF
					»«ENDIF
				»«ENDIF
			»«ENDFOR
		»«ENDIF
	»«ENDIF»'''
	
	def compile(Decls d)'''
		«FOR dec:d.decls»
			«dec.compile»
		«ENDFOR»
	'''
	
	def compile(Decl d)'''
		«IF d.function!==null»
			«d.function.compile»
		«ELSE» «IF d.field!==null»
			«d.field.compile»
			«ENDIF»
		«ENDIF»
	'''
	
	def compile(FieldDecl f)
	'''
	//FieldDecl'''
	
	def compile(FnDecl f)'''
	//FnDecl
	«IF f.body»
	«f.fnItself.compile»
	«ENDIF»'''
	
	def String compile(Stmnts st)'''
	//Statements
	«IF st.front!==null»«st.front.compile»«
	ELSE»«IF st.locVar!==null»«st.locVar.compile»«
	ELSE»
	«IF st.exp!==null»«st.exp.compile
	»«ENDIF»
	«ENDIF»«ENDIF»
	'''
	
	def compile(Stmnt s)'''
	//Statement«s.delim.compile»
	'''
	
	def compile(DelimitedExpr d)'''
	//DelimExpr«d.dod.compile»
	'''
	
	def compile(Do d)'''
	//Do«d.dofs.get(0).compile»
	'''
	
	def compile(DoFront df)'''
	//DoFront«df.block.compile»
	'''
	
	def compile(BlockElems bs)'''
	//BlockElems«bs.block.get(0).compile»
«««	«bs.block.get(1).compile»
	'''
	
	def compile (BlockElem b)'''
	//BlockElem«b.st.compile»
	'''
	
	def compile(LocalVarDecl d)'''
	//LocalVar «d.init.compile»
	'''
	
	def compile(Expr e)'''
	//Expr«e.front.compile»
	'''
	
	def compile(ExprFront ef)'''
	//ExprFront«ef.add.compile»
	'''
	
	def String compile(CommaExpr ce){
		var String s = "//CommaExpr"
		switch(ce)
		{
			Qualified:s=s+"yolo"
			Primary:s=s+ce.exp.compile
			AddExpr:s=s+"noYolo"
			LiteralTuple:s=s+ce.lit.lit.intg.toString
		}
		return s
		}
   
}