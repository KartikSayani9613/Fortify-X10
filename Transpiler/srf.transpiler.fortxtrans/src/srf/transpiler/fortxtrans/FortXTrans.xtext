grammar srf.transpiler.fortxtrans.FortXTrans with org.eclipse.xtext.common.Terminals

generate fortXTrans "http://www.transpiler.srf/fortxtrans/FortXTrans"

Model:
	Component
	|API
;


Component:
	'component' name=ID (imports+=Import)* (exports+=Export)+ (decls+=Decls)* 'end'
;

API:
	'api' name=ID (imports+=Import)* /*(absDecls+=AbsDecls)**/ 'end'
;


Import:
	imps='import' importedNames=ImportedNames
	|imps='import' api='api' aliasedimportedNames=AliasedAPINames
	
;

Export:
	exp='export' exportedName+=APIName
	|exp='export' brack='{' exportedName+=APIName ("," exportedName+=APIName)* '}'
;

ImportedNames:
	impname=APIName '.' '{' DOTS '}' (except?='except' simp=SimpleNames)?
	|impname=APIName '.' '{' simpList+=AliasedSimpleName (',' simpList+= AliasedSimpleName)* (comma?=',' dots?=DOTS)? '}'
	|impname=APIName ('as' asname=ID)?
;

QualifiedName:
	ID DOTS
	|ID ('.'ID)* DOTS
	|ID ('.'ID)*
;

APIName:
	ID DOTS
	|ID ('.'ID)* DOTS
	|ID ('.'ID)*
;

SimpleNames:
	nameList+=SimpleName
	|brack='{' nameList+=SimpleName (',' nameList+=SimpleName)* '}'
;

SimpleName:
	name=ID
;

AliasedSimpleName:
	orig=ID ('as' asName=ID)?
;

AliasedAPINames:
	nameList+=AliasedAPIName
	|brack='{' nameList+=AliasedAPIName (',' nameList+=AliasedAPIName)* '}'
;

AliasedAPIName:
	orig=APIName ('as' asName=ID)?
;

Decls:
	(decls+=Decl)+
;

Decl:
	function=FnDecl
//	|var=VarDecl
//	|object=ObjDecl
//	|trait=TraitDecl
;



FnMods:
	(mods+=FnMod)+
;

FnMod:
	modtype='private'
	|modtype='test'
	|modtype='atomic'
	|modtype='io'
;


ValParam:
	params+=Param
	 |brack='(' (params+=Param (',' params+=Param)*)? ')'
;

Param:
	bId=BindId istype=IsType
;

RetType:
	':' empty='(' ')'
	|':' type=Type
;

Type:
	tname=ID
;



FnDecl:
	(mods=FnMods)? name=ID params=ValParam (retVal=RetType)? (body?='=' fnItself=Expression)?
;

Expression:
	exp=Expr
;

Expr:
	front=ExprFront (tails+=ExprTail)*
;

ExprFront:
	delim=DelimitedExpr
	|id=QualifiedName
;

ExprTail:
	'as' type=Type
;

DelimitedExpr :
	dod=Do
	|awhile='while' expr=Expr  whiledod=Do
	|afor='for' gen=Generators dofront=DoFront 'end'
	|anif='if' cond=Expr 'then' block=BlockElems (elifs=Elifs)? (else=Else)? 'end'
	|par=Paranthesized
;

Elifs:
	e+=Elif (e+=Elif)*
;

Elif:
	'elif' expr=Expr 'then' block=BlockElems
;

Else:
	'else' block=BlockElems
;

Generators:
	binding=Binding (',' clause+=GenClause)*
;

Binding:
	idtup=IdOrTuple '<-' expr=Expr
;

GenClause:
	binding=Binding
	|expr=Expr
;

BlockElems:
	block+=BlockElem (block+=BlockElem)*
;

BlockElem returns Expression:
	exp=Expr
;

Paranthesized returns Expression:
	'(' Expr {Paranthesized.expr=current} ')'
;

Do:
	dofs+=DoFront ('also' dofs+=DoFront)* "end"
;

DoFront:
	(at?='at' exp=Expr)? (atom?='atomic')? 'do' block=BlockElems
;


IdOrTuple:
	bid+=BindId
	|'(' bid+=BindId (',' bid+=BindId)* ')'	
;

BindId:
	ID
	|'_'
;

IsType:
	':' type=Type
;

@Override 
terminal ML_COMMENT:
	'(*' -> '*)'
;

terminal GREATERS:
	'>' (SD '>')*
;

terminal LESSES:
	'<' (SD '<')*
;

terminal BARS:
	'|' (SD '|')*
;

terminal SLASHES:
	 "/" (SD "/")*
;

terminal SD:
	('.'|'*')?
;

terminal LEFT_ENCLOSER:
	'(' ('/'+ | '\\'+)
	|'[/\\/\\/' | '[/\\/'
	|'[' (SD SLASHES)
	|LESSES SD (SLASHES |BARS)
	|BARS SD SLASHES
	|('{*' | '[*')
	|('((>' | '(<')
; 

terminal RIGHT_ENCLOSER:
	'/'+ ')'
	|'\\'+ ')'
	|SLASHES SD (GREATERS | BARS | ('\\'|']'))
	|BARS SD GREATERS
	|('*]' | '*}')
	|"]"
	|(">)" | "<))")
	| "/\\/\\/]" | "/\\/]"
;

terminal DOTS:
	'...'
;

