grammar srf.transpiler.fortxtrans.FortXTrans with org.eclipse.xtext.common.Terminals

generate fortXTrans "http://www.transpiler.srf/fortxtrans/FortXTrans"

Model:
	Component
	|API
;


Component:
	'component' name=ID (imports+=Import)* (exports+=Export)+ (decls+=Decls)* 'end'
;

API:
	'api' name=ID (imports+=Import)* /*(absDecls+=AbsDecls)**/ 'end'
;

Import:
	imps='import' importedNames=ImportedNames
	|imps='import' api='api' aliasedimportedNames=AliasedAPINames
	
;

Export:
	exp='export' exportedName+=APIName
	|exp='export' brack='{' exportedName+=APIName ("," exportedName+=APIName)* '}'
;

ImportedNames:
	impname=APIName '.' '{' DOTS '}' (except?='except' simp=SimpleNames)?
	|impname=APIName '.' '{' simpList+=AliasedSimpleName (',' simpList+= AliasedSimpleName)* (comma?=',' dots?=DOTS)? '}'
	|impname=APIName ('as' asname=ID)?
;

QualifiedName:
	ID DOTS
	|ID ('.'ID)* DOTS
	|ID ('.'ID)*
;

APIName:
	ID DOTS
	|ID ('.'ID)* DOTS
	|ID ('.'ID)*
;

SimpleNames:
	nameList+=SimpleName
	|brack='{' nameList+=SimpleName (',' nameList+=SimpleName)* '}'
;

SimpleName:
	name=ID
;

AliasedSimpleName:
	orig=ID ('as' asName=ID)?
;

AliasedAPINames:
	nameList+=AliasedAPIName
	|brack='{' nameList+=AliasedAPIName (',' nameList+=AliasedAPIName)* '}'
;

AliasedAPIName:
	orig=APIName ('as' asName=ID)?
;

Decls:
	(decls+=Decl)+
;

Decl:
	function=FnDecl
	|field=FieldDecl
//	|object=ObjDecl
//	|trait=TraitDecl
;

FnMods:
	(mods+=FnMod)+
;

FnMod:
	modtype='private'
	|modtype='test'
	|modtype='atomic'
	|modtype='io'
;

ValParam:
	params+=Param
	 |brack='(' (params+=Param (',' params+=Param)*)? ')'
;

Param:
	bId=BindId istype=IsType
;

RetType:
	':' empty='(' ')'
	|':' type=Type
;

TupleType:
	'(' types+=Type (',' types+=Type)* ')'
;

Type:
	tname=ID
;

FnDecl:
	(mods=FnMods)? name=ID params=ValParam (retVal=RetType)? (body?='=' fnItself=Stmnt)?
;

Stmnt:
	front=ExprFront (tails+=ExprTail)*
	|locVar=LocalVarDecl
	|exp=Expr
;

Expr:
	lit=LiteralTuple
;

ExprFront:
	delim=DelimitedExpr
;

ExprTail:
	'as' type=Type
;

DelimitedExpr :
	dod=Do
	|lits=LiteralTuple eqop=':=' pblock=ParBlockElems
	|ret='return' block=BlockElem
	|awhile='while' expr=Expr  whiledod=Do
	|afor='for' gen=Generators dofront=DoFront 'end'
	|anif='if' cond=Expr 'then' blocks=BlockElems (elifs=Elifs)? (els=Else)? 'end'
	|'|' parblock=ParBlockElems '|'
	|fname=QualifiedName brack='(' fargs=ExprList ')'
;

ExprList:
	exp+=Expr (',' exp+=Expr)*
;

ParBlockElems:
	 brack='(' block+=BlockElem (',' block+=BlockElem)* ')'
;

Elifs:
	e+=Elif (e+=Elif)*
;

Elif:
	'elif' expr=Expr 'then' block=BlockElems
;

Else:
	'else' block=BlockElems
;

Generators:
	binding=Binding (',' clause+=GenClause)*
;

Binding:
	idtup=IdOrTuple '<-' expr=Expr
	|idtup=IdOrTuple '<-' seq='seq' '('expr=Expr')'
;

GenClause:
	binding=Binding
	|expr=Expr
;

BlockElems:
	block+=BlockElem (block+=BlockElem)*
;

BlockElem:
	st=Stmnt
//	|locVar+=LocalVarDecl
;

Do:
	dofs+=DoFront ('also' dofs+=DoFront)* "end"
;

DoFront:
	(at?='at' exp=Expr)? (atom?='atomic')? 'do' block=BlockElems
;


IdOrTuple:
	bid+=BindId
	|'(' bid+=BindId (',' bid+=BindId)* ')'	
;

BindId:
	ID
	|'_'
;

IsType:
	':' type=Type
;
//For a field Decl, If you 'var' has been used it will be mutable. 
//If 'var' has not been used check '=' for immutable and ':=' for mutable.
FieldDecl:
	(pri='private')? (mut='var')? vars=NoNewlineVarWTypes init=InitVal
	|(pri='private')? idtup=IdOrTuple '=' litTup=LiteralTuple
	|(pri='private')? (mut='var')? idtup=IdOrTuple ':' type=Type DOTS init=InitVal
	|(pri='private')? (mut='var')? idtup=IdOrTuple ':' tuptype=TupleType init=InitVal
;

NoNewlineVarWTypes:
	single=NoNewlineVarWType
	| "(" multiple+=NoNewlineVarWType ( "," multiple+=NoNewlineVarWType)+ ")"
;
NoNewlineVarWType:
	bid=BindId istype=IsType
;

InitVal:
	mut=':=' lit=LiteralTuple
	|immut='=' lit=LiteralTuple
;

LiteralTuple:
	lit=Literal
	|'(' lits+=Literal (',' lits+=Literal)+ ')'
;

Literal:
	intg=INT
	|flot=FLOAT
	|str=STRING
	|q=QualifiedName
;


LocalVarDecl:
	(mut='var')? vars=NoNewlineVarWTypes (muta=':='|immut='=') init=Expr
	|idtup=IdOrTuple '=' litTup=LiteralTuple
	|(mut='var')? idtup=IdOrTuple ':' type=Type DOTS (muta=':='|immut='=') init=Expr
	|(mut='var')? idtup=IdOrTuple ':' tuptype=TupleType (muta=':='|immut='=') init=Expr
;

@Override 
terminal ML_COMMENT:
	'(*' -> '*)'
;

terminal FLOAT:
	INT'.'INT
;

terminal GREATERS:
	'>' (SD '>')*
;

terminal LESSES:
	'<' (SD '<')*
;

terminal BARS:
	'|' (SD '|')*
;

terminal SLASHES:
	 "/" (SD "/")*
;

terminal SD:
	('.'|'*')?
;

terminal LEFT_ENCLOSER:
	'(' ('/'+ | '\\'+)
	|'[/\\/\\/' | '[/\\/'
	|'[' (SD SLASHES)
	|LESSES SD (SLASHES |BARS)
	|BARS SD SLASHES
	|('{*' | '[*')
	|('((>' | '(<')
; 

terminal RIGHT_ENCLOSER:
	'/'+ ')'
	|'\\'+ ')'
	|SLASHES SD (GREATERS | BARS | ('\\'|']'))
	|BARS SD GREATERS
	|('*]' | '*}')
	|"]"
	|(">)" | "<))")
	| "/\\/\\/]" | "/\\/]"
;

terminal DOTS:
	'...'
;

