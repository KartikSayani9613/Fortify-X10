grammar srf.transpiler.fortxtrans.FortXTrans with org.eclipse.xtext.common.Terminals

generate fortXTrans "http://www.transpiler.srf/fortxtrans/FortXTrans"

Model:
	Component
	|API
;


Component:
	'component' name=ID (imports+=Import)* (exports+=Export)+ (decls+=Decls)* 'end'
;

API:
	'api' name=ID (imports+=Import)* /*(absDecls+=AbsDecls)**/ 'end'
;

Import:
	imps='import' importedNames=ImportedNames
	|imps='import' api='api' aliasedimportedNames=AliasedAPINames
	
;

Export:
	exp='export' exportedName+=QualifiedName
	|exp='export' brack='{' exportedName+=QualifiedName ("," exportedName+=QualifiedName)* '}'
;

ImportedNames:
	impname=QualifiedName '.' '{' DOTS '}' (except?='except' simp=SimpleNames)?
	|impname=QualifiedName '.' '{' simpList+=AliasedSimpleName (',' simpList+= AliasedSimpleName)* (comma?=',' dots?=DOTS)? '}'
	|impname=QualifiedName ('as' asname=ID)?
;

QualifiedName:
	s+=SimpleName (dots=DOTS)?
	|s+=SimpleName ('.'s+=SimpleName)+ (dots=DOTS)?
;

Qualified:
	q=QualifiedName
	|qlist=QualifiedNameTuple
;

QualifiedNameTuple:
	'('qlist+=QualifiedName (',' qlist+=QualifiedName)* ')'
;

SimpleNames:
	nameList+=SimpleName
	|brack='{' nameList+=SimpleName (',' nameList+=SimpleName)* '}'
;

SimpleName:
	name=ID
;

AliasedSimpleName:
	orig=ID ('as' asName=ID)?
;

AliasedAPINames:
	nameList+=AliasedAPIName
	|brack='{' nameList+=AliasedAPIName (',' nameList+=AliasedAPIName)* '}'
;

AliasedAPIName:
	orig=QualifiedName ('as' asName=ID)?
;

Decls:
	(decls+=Decl)+
;

Decl:
	function=FnDecl
	|field=FieldDecl
//	|object=ObjDecl
//	|trait=TraitDecl
;

FnMods:
	(mods+=FnMod)+
;

FnMod:
	modtype='private'
	|modtype='test'
	|modtype='atomic'
	|modtype='io'
;

ValParam:
	params+=Param
	 |brack='(' (params+=Param (',' params+=Param)*)? ')'
;

Param:
	bId=BindId istype=IsType
;

RetType:
	':' empty='(' ')'
	|':' type=SimpleName
;

TupleType:
	'(' types+=SimpleName (',' types+=SimpleName)* ')'
;

FnDecl:
	(mods=FnMods)? name=ID params=ValParam (retVal=RetType)? (body?='=' fnItself=Stmnts)?
;

Stmnts:
	front=Stmnt
	|locVar=LocalVarDecl
	|exp=Expr
;

Stmnt:
	delim=DelimitedExpr
	|brack='(' delimList=DelimitedExprList ')'
;

DelimitedExprList:
	delim+=DelimitedExpr (',' delim+=DelimitedExpr)+
;

Expr:
	front=ExprFront (tail+=ExprTail)*
;

ExprFront:
	add=CommaExpr 
;

CommaExpr:
	AddExpr ({CommaExpr.left=current} ',' right=AddExpr)*
;

AddExpr returns Expr:
	SubExpr ({AddExpr.left=current}'+' right=SubExpr)*
;

SubExpr returns Expr:
	DivExpr ({SubExpr.left=current}'-' right=DivExpr)*
;

DivExpr returns Expr:
	MultExpr ({DivExpr.left=current}'/' right=MultExpr)*
;

MultExpr returns Expr:
	Primary ({MultExpr.left=current}'*' right=Primary)*
;

Primary returns Expr:
	Qualified ({Primary.left=current}':=' exp=Expr)? ({Primary.Fname=current}'(' fargs = Expr ')')?
	|LiteralTuple
	|'('exp=Expr')'
;


ExprTail:
	'as' type=SimpleName
;

DelimitedExpr :
	dod=Do
	|ret='return' block=BlockElem
	|awhile='while' expr=Expr  whiledod=Do
	|afor='for' gen=Generators dofront=DoFront 'end'
	|anif='if' cond=Expr 'then' blocks=BlockElems (elifs=Elifs)? (els=Else)? 'end'
;

Elifs:
	e+=Elif (e+=Elif)*
;

Elif:
	'elif' expr=Expr 'then' block=BlockElems
;

Else:
	'else' block=BlockElems
;

Generators:
	binding=Binding (',' clause+=GenClause)*
;

Binding:
	idtup=IdOrTuple '<-' expr=Expr
	|idtup=IdOrTuple '<-' seq='seq' '('expr=Expr')'
;

GenClause:
	binding=Binding
	|expr=Expr
;

BlockElems:
	block+=BlockElem (block+=BlockElem)*
;

BlockElem:
	st=Stmnts
//	|locVar+=LocalVarDecl
;

Do:
	dofs+=DoFront ('also' dofs+=DoFront)* "end"
;

DoFront:
	(at?='at' exp=Expr)? (atom?='atomic')? 'do' block=BlockElems
;


IdOrTuple:
	bid+=BindId
	|'(' bid+=BindId (',' bid+=BindId)* ')'	
;

BindId:
	s=SimpleName
	|undsc='_'
;

IsType:
	':' type=SimpleName
;
//For a field Decl, If you 'var' has been used it will be mutable. 
//If 'var' has not been used check '=' for immutable and ':=' for mutable.
FieldDecl:
	(pri='private')? (mut='var')? vars=NoNewlineVarWTypes init=InitVal
	|(pri='private')? idtup=IdOrTuple '=' litTup=LiteralTuple
	|(pri='private')? (mut='var')? idtup=IdOrTuple ':' type=SimpleName DOTS init=InitVal
	|(pri='private')? (mut='var')? idtup=IdOrTuple ':' tuptype=TupleType init=InitVal
;

NoNewlineVarWTypes:
	single=NoNewlineVarWType
	| "(" multiple+=NoNewlineVarWType ( "," multiple+=NoNewlineVarWType)+ ")"
;
NoNewlineVarWType:
	bid=BindId istype=IsType
;

InitVal:
	mut=':=' lit=LiteralTuple
	|immut='=' lit=LiteralTuple
;

LiteralTuple:
	lit=LiteralTup
	|qname=QualifiedName
	|qlist=QualifiedNameTuple
;

LiteralTup:
	lit=Literal
	|'(' lits+=Literal (',' lits+=Literal)+ ')'
;

Literal:
	intg=INT
	|flot=FLOAT
	|str=STRING
;

LocalVarDecl:
	(mut='var')? vars=NoNewlineVarWTypes '=' init=Expr
	|idtup=IdOrTuple '=' litTup=LiteralTuple
	|(mut='var')? idtup=IdOrTuple ':' type=SimpleName DOTS "=" init=Expr
	|(mut='var')? idtup=IdOrTuple ':' tuptype=TupleType '=' init=Expr
;

@Override 
terminal ML_COMMENT:
	'(*' -> '*)'
;

terminal FLOAT:
	INT'.'INT
;

terminal DOTS:
	'...'
;