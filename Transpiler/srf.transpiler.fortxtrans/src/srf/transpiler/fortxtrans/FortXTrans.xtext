grammar srf.transpiler.fortxtrans.FortXTrans with org.eclipse.xtext.common.Terminals

generate fortXTrans "http://www.transpiler.srf/fortxtrans/FortXTrans"

Model:
	Component
	|API
;


Component:
	'component' name=ID (imports+=Import)* (exports+=Export)+ (decls+=Decls)* 'end'
;

API:
	'api' name=ID (imports+=Import)* /*(absDecls+=AbsDecls)**/ 'end'
;


Import:
	imps='import' importedNames=ImportedNames
	|imps='import' api='api' aliasedimportedNames=AliasedAPINames
	
;

Export:
	exp='export' exportedName+=APIName
	|exp='export' brack='{' exportedName+=APIName ("," exportedName+=APIName)* '}'
;

ImportedNames:
	impname=APIName '.' '{' DOTS '}' (except?='except' simp=SimpleNames)?
	|impname=APIName '.' '{' simpList+=AliasedSimpleName (',' simpList+= AliasedSimpleName)* (comma?=',' dots?=DOTS)? '}'
	|impname=APIName ('as' asname=ID)?
;

QualifiedName:
	ID DOTS
	|ID ('.'ID)* DOTS
	|ID ('.'ID)*
;

APIName:
	ID DOTS
	|ID ('.'ID)* DOTS
	|ID ('.'ID)*
;

SimpleNames:
	nameList+=SimpleName
	|brack='{' nameList+=SimpleName (',' nameList+=SimpleName)* '}'
;

SimpleName:
	name=ID
;

AliasedSimpleName:
	orig=ID ('as' asName=ID)?
;

AliasedAPINames:
	nameList+=AliasedAPIName
	|brack='{' nameList+=AliasedAPIName (',' nameList+=AliasedAPIName)* '}'
;

AliasedAPIName:
	orig=APIName ('as' asName=ID)?
;

Decls:
	(decls+=Decl)+
;

Decl:
	function=FnDecl
;

FnDecl:
	(mods=FnMods)? fnName=ID params=ValParam ':' return=RetType ('=' fnItself=Expression)?
;

FnMods:
	(mods+=FnMod)+
;

FnMod:
	absMod=AbsFnMod
	|pri='private'
;

AbsFnMod:
	local=LocalFnMod
	|test='test'
;

LocalFnMod:
	'atomic'
	|'io'
;

ValParam:
	bindID=BindId
	 |brack='(' (params+=Param (',' params+=Param)*)? ')'
;

Param:
	bId=BindId istype=IsType
;

BindId:
	ID
	|'_'
;

IsType:
	':' type=Type
;

RetType:
	'(' ')'{RetType}
	|type=Type
;

Type:
	tname=ID
;

Expression:
	exp=Expr
;

Expr returns Expression:
	ExprFront {Expr.front=current} (tails+=ExprTail)*
;

ExprFront returns Expression:
	DelimitedExpr {ExprFront.delim=current}
	|id=QualifiedName
;

ExprTail:
	'as' Type
;

DelimitedExpr returns Expression:
	Do
	|Paranthesized {Delimited.par=current}
;

Paranthesized returns Expression:
	'(' Expr {Paranthesized.expr=current} ')'
;

Do returns Expression:
	DoFront {Do.dofs+=current} ('also' dofs+=DoFront)* "end"
;

DoFront returns Expression:
	(atom='atomic')? 'do' block=BlockElem
;

BlockElem returns Expression:
	Expr {BlockELem.expr=current}
;




@Override 
terminal ML_COMMENT:
	'(*' -> '*)'
;

terminal GREATERS:
	'>' (SD '>')*
;

terminal LESSES:
	'<' (SD '<')*
;

terminal BARS:
	'|' (SD '|')*
;

terminal SLASHES:
	 "/" (SD "/")*
;

terminal SD:
	('.'|'*')?
;

terminal LEFT_ENCLOSER:
	'(' ('/'+ | '\\'+)
	|'[/\\/\\/' | '[/\\/'
	|'[' (SD SLASHES)
	|LESSES SD (SLASHES |BARS)
	|BARS SD SLASHES
	|('{*' | '[*')
	|('((>' | '(<')
; 

terminal RIGHT_ENCLOSER:
	'/'+ ')'
	|'\\'+ ')'
	|SLASHES SD (GREATERS | BARS | ('\\'|']'))
	|BARS SD GREATERS
	|('*]' | '*}')
	|"]"
	|(">)" | "<))")
	| "/\\/\\/]" | "/\\/]"
;

terminal DOTS:
	'...'
;

